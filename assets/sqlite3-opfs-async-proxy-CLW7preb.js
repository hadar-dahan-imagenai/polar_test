var Y=Object.defineProperty;var c=(f,t)=>Y(f,"name",{value:t,configurable:!0});(function(){try{var f=typeof window<"u"?window:typeof global<"u"?global:typeof self<"u"?self:{},t=new f.Error().stack;t&&(f._sentryDebugIds=f._sentryDebugIds||{},f._sentryDebugIds[t]="786b1fd8-b808-48b9-978e-d53ce333a0fc",f._sentryDebugIdIdentifier="sentry-dbid-786b1fd8-b808-48b9-978e-d53ce333a0fc")}catch{}})();const C=c((f,...t)=>postMessage({type:f,payload:t}),"wPost"),J=c(function(){const f=c(function(...e){throw new Error(e.join(" "))},"toss");globalThis.window===globalThis?f("This code cannot run from the main thread.","Load it as a Worker from a separate Worker."):navigator?.storage?.getDirectory||f("This API requires navigator.storage.getDirectory.");const t=Object.create(null);t.verbose=1;const U={0:console.error.bind(console),1:console.warn.bind(console),2:console.log.bind(console)},z=c((e,...s)=>{t.verbose>e&&U[e]("OPFS asyncer:",...s)},"logImpl"),T=c((...e)=>z(2,...e),"log"),P=c((...e)=>z(1,...e),"warn"),_=c((...e)=>z(0,...e),"error"),d=Object.create(null);d.reset=()=>{let e;const s=c(o=>o.count=o.time=o.wait=0,"r");for(e in t.opIds)s(d[e]=Object.create(null));let n=d.s11n=Object.create(null);n=n.serialize=Object.create(null),n.count=n.time=0,n=d.s11n.deserialize=Object.create(null),n.count=n.time=0},d.dump=()=>{let e,s=0,n=0,o=0;for(e in t.opIds){const i=d[e];s+=i.count,n+=i.time,o+=i.wait,i.avgTime=i.count&&i.time?i.time/i.count:0}globalThis?.location?.href,globalThis?.location?.href,d.s11n};const E=Object.create(null),L=new Set,V=c(function(e,s){const n=new URL(e,"file://irrelevant").pathname;return s?n.split("/").filter(o=>!!o):n},"getResolvedPath"),D=c(async function(s,n=!1){const o=V(s,!0),i=o.pop();let a=t.rootDir;for(const l of o)l&&(a=await a.getDirectoryHandle(l,{create:!!n}));return[a,i]},"f"),N=c(async e=>{if(e.syncHandle){T("Closing sync handle for",e.filenameAbs);const s=e.syncHandle;return delete e.syncHandle,delete e.xLock,L.delete(e.fid),s.close()}},"closeSyncHandle"),W=c(async e=>{try{await N(e)}catch(s){P("closeSyncHandleNoThrow() ignoring:",s,e)}},"closeSyncHandleNoThrow"),K=c(async()=>{if(L.size)for(const e of L){const s=E[e];await W(s),T("Auto-unlocked",e,s.filenameAbs)}},"releaseImplicitLocks"),F=c(async e=>{if(e.releaseImplicitLocks&&L.has(e.fid))return W(e)},"releaseImplicitLock");class x extends Error{static{c(this,"GetSyncHandleError")}constructor(s,...n){super([...n,": "+s.name+":",s.message].join(" "),{cause:s}),this.name="GetSyncHandleError"}}x.convertRc=(e,s)=>e instanceof x&&(e.cause.name==="NoModificationAllowedError"||e.cause.name==="DOMException"&&e.cause.message.indexOf("Access Handles cannot")===0)?t.sq3Codes.SQLITE_BUSY:s;const k=c(async(e,s)=>{if(!e.syncHandle){const n=performance.now();T("Acquiring sync handle for",e.filenameAbs);const o=6,i=t.asyncIdleWaitTime*2;let a=1,l=i;for(;;l=i*++a)try{e.syncHandle=await e.fileHandle.createSyncAccessHandle();break}catch(r){if(a===o)throw new x(r,"Error getting sync handle for",s+"().",o,"attempts failed.",e.filenameAbs);P("Error getting sync handle for",s+"(). Waiting",l,"ms and trying again.",e.filenameAbs,r),Atomics.wait(t.sabOPView,t.opIds.retry,0,l)}T("Got",s+"() sync handle for",e.filenameAbs,"in",performance.now()-n,"ms"),e.xLock||(L.add(e.fid),T("Acquired implicit lock for",s+"()",e.fid,e.filenameAbs))}return e.syncHandle},"getSyncHandle"),y=c((e,s)=>{T(e+"() => notify(",s,")"),Atomics.store(t.sabOPView,t.opIds.rc,s),Atomics.notify(t.sabOPView,t.opIds.rc)},"storeAndNotify"),B=c(function(e,s){s.readOnly&&f(e+"(): File is read-only: "+s.filenameAbs)},"affirmNotRO"),A=Object.create(null);A.op=void 0,A.start=void 0;const b=c(e=>{A.start=performance.now(),A.op=e,++d[e].count},"mTimeStart"),m=c(()=>d[A.op].time+=performance.now()-A.start,"mTimeEnd"),R=Object.create(null);R.op=void 0,R.start=void 0;const g=c(e=>{R.start=performance.now(),R.op=e},"wTimeStart"),p=c(()=>d[R.op].wait+=performance.now()-R.start,"wTimeEnd");let H=!1;const v={"opfs-async-metrics":async()=>{b("opfs-async-metrics"),d.dump(),y("opfs-async-metrics",0),m()},"opfs-async-shutdown":async()=>{H=!0,y("opfs-async-shutdown",0)},mkdir:async e=>{b("mkdir");let s=0;g("mkdir");try{await D(e+"/filepart",!0)}catch(n){t.s11n.storeException(2,n),s=t.sq3Codes.SQLITE_IOERR}finally{p()}y("mkdir",s),m()},xAccess:async e=>{b("xAccess");let s=0;g("xAccess");try{const[n,o]=await D(e);await n.getFileHandle(o)}catch(n){t.s11n.storeException(2,n),s=t.sq3Codes.SQLITE_IOERR}finally{p()}y("xAccess",s),m()},xClose:async function(e){const s="xClose";b(s),L.delete(e);const n=E[e];let o=0;if(g(s),n){if(delete E[e],await N(n),n.deleteOnClose)try{await n.dirHandle.removeEntry(n.filenamePart)}catch(i){P("Ignoring dirHandle.removeEntry() failure of",n,i)}}else t.s11n.serialize(),o=t.sq3Codes.SQLITE_NOTFOUND;p(),y(s,o),m()},xDelete:async function(...e){b("xDelete");const s=await v.xDeleteNoWait(...e);y("xDelete",s),m()},xDeleteNoWait:async function(e,s=0,n=!1){let o=0;g("xDelete");try{for(;e;){const[i,a]=await D(e,!1);if(!a||(await i.removeEntry(a,{recursive:n}),s!==4660))break;n=!1,e=V(e,!0),e.pop(),e=e.join("/")}}catch(i){t.s11n.storeException(2,i),o=t.sq3Codes.SQLITE_IOERR_DELETE}return p(),o},xFileSize:async function(e){b("xFileSize");const s=E[e];let n=0;g("xFileSize");try{const o=await(await k(s,"xFileSize")).getSize();t.s11n.serialize(Number(o))}catch(o){t.s11n.storeException(1,o),n=x.convertRc(o,t.sq3Codes.SQLITE_IOERR)}await F(s),p(),y("xFileSize",n),m()},xLock:async function(e,s){b("xLock");const n=E[e];let o=0;const i=n.xLock;if(n.xLock=s,!n.syncHandle){g("xLock");try{await k(n,"xLock"),L.delete(e)}catch(a){t.s11n.storeException(1,a),o=x.convertRc(a,t.sq3Codes.SQLITE_IOERR_LOCK),n.xLock=i}p()}y("xLock",o),m()},xOpen:async function(e,s,n,o){const i="xOpen";b(i);const a=t.sq3Codes.SQLITE_OPEN_CREATE&n;g("xOpen");try{let l,r;try{[l,r]=await D(s,!!a)}catch(u){t.s11n.storeException(1,u),y(i,t.sq3Codes.SQLITE_NOTFOUND),m(),p();return}if(t.opfsFlags.OPFS_UNLINK_BEFORE_OPEN&o)try{await l.removeEntry(r)}catch{}const S=await l.getFileHandle(r,{create:a});p();const I=Object.assign(Object.create(null),{fid:e,filenameAbs:s,filenamePart:r,dirHandle:l,fileHandle:S,sabView:t.sabFileBufView,readOnly:a?!1:t.sq3Codes.SQLITE_OPEN_READONLY&n,deleteOnClose:!!(t.sq3Codes.SQLITE_OPEN_DELETEONCLOSE&n)});I.releaseImplicitLocks=o&t.opfsFlags.OPFS_UNLOCK_ASAP||t.opfsFlags.defaultUnlockAsap,E[e]=I,y(i,0)}catch(l){p(),_(i,l),t.s11n.storeException(1,l),y(i,t.sq3Codes.SQLITE_IOERR)}m()},xRead:async function(e,s,n){b("xRead");let o=0,i;const a=E[e];try{g("xRead"),i=(await k(a,"xRead")).read(a.sabView.subarray(0,s),{at:Number(n)}),p(),i<s&&(a.sabView.fill(0,i,s),o=t.sq3Codes.SQLITE_IOERR_SHORT_READ)}catch(l){i===void 0&&p(),_("xRead() failed",l,a),t.s11n.storeException(1,l),o=x.convertRc(l,t.sq3Codes.SQLITE_IOERR_READ)}await F(a),y("xRead",o),m()},xSync:async function(e,s){b("xSync");const n=E[e];let o=0;if(!n.readOnly&&n.syncHandle){try{g("xSync"),await n.syncHandle.flush()}catch(i){t.s11n.storeException(2,i),o=t.sq3Codes.SQLITE_IOERR_FSYNC}p()}y("xSync",o),m()},xTruncate:async function(e,s){b("xTruncate");let n=0;const o=E[e];g("xTruncate");try{B("xTruncate",o),await(await k(o,"xTruncate")).truncate(s)}catch(i){_("xTruncate():",i,o),t.s11n.storeException(2,i),n=x.convertRc(i,t.sq3Codes.SQLITE_IOERR_TRUNCATE)}await F(o),p(),y("xTruncate",n),m()},xUnlock:async function(e,s){b("xUnlock");let n=0;const o=E[e];if(t.sq3Codes.SQLITE_LOCK_NONE===s&&o.syncHandle){g("xUnlock");try{await N(o)}catch(i){t.s11n.storeException(1,i),n=t.sq3Codes.SQLITE_IOERR_UNLOCK}p()}y("xUnlock",n),m()},xWrite:async function(e,s,n){b("xWrite");let o;const i=E[e];g("xWrite");try{B("xWrite",i),o=s===(await k(i,"xWrite")).write(i.sabView.subarray(0,s),{at:Number(n)})?0:t.sq3Codes.SQLITE_IOERR_WRITE}catch(a){_("xWrite():",a,i),t.s11n.storeException(1,a),o=x.convertRc(a,t.sq3Codes.SQLITE_IOERR_WRITE)}await F(i),p(),y("xWrite",o),m()}},G=c(()=>{if(t.s11n)return t.s11n;const e=new TextDecoder,s=new TextEncoder("utf-8"),n=new Uint8Array(t.sabIO,t.sabS11nOffset,t.sabS11nSize),o=new DataView(t.sabIO,t.sabS11nOffset,t.sabS11nSize);t.s11n=Object.create(null);const i=Object.create(null);i.number={id:1,size:8,getter:"getFloat64",setter:"setFloat64"},i.bigint={id:2,size:8,getter:"getBigInt64",setter:"setBigInt64"},i.boolean={id:3,size:4,getter:"getInt32",setter:"setInt32"},i.string={id:4};const a=c(r=>i[typeof r]||f("Maintenance required: this value type cannot be serialized.",r),"getTypeId"),l=c(r=>{switch(r){case i.number.id:return i.number;case i.bigint.id:return i.bigint;case i.boolean.id:return i.boolean;case i.string.id:return i.string;default:f("Invalid type ID:",r)}},"getTypeIdById");return t.s11n.deserialize=function(r=!1){++d.s11n.deserialize.count;const S=performance.now(),I=n[0],u=I?[]:null;if(I){const h=[];let w=1,O,q,Q;for(O=0;O<I;++O,++w)h.push(l(n[w]));for(O=0;O<I;++O){const j=h[O];j.getter?(Q=o[j.getter](w,t.littleEndian),w+=j.size):(q=o.getInt32(w,t.littleEndian),w+=4,Q=e.decode(n.slice(w,w+q)),w+=q),u.push(Q)}}return r&&(n[0]=0),d.s11n.deserialize.time+=performance.now()-S,u},t.s11n.serialize=function(...r){const S=performance.now();if(++d.s11n.serialize.count,r.length){const I=[];let u=0,h=1;for(n[0]=r.length&255;u<r.length;++u,++h)I.push(a(r[u])),n[h]=I[u].id;for(u=0;u<r.length;++u){const w=I[u];if(w.setter)o[w.setter](h,r[u],t.littleEndian),h+=w.size;else{const O=s.encode(r[u]);o.setInt32(h,O.byteLength,t.littleEndian),h+=4,n.set(O,h),h+=O.byteLength}}}else n[0]=0;d.s11n.serialize.time+=performance.now()-S},t.s11n.storeException=t.asyncS11nExceptions?(r,S)=>{r<=t.asyncS11nExceptions&&t.s11n.serialize([S.name,": ",S.message].join(""))}:()=>{},t.s11n},"initS11n"),M=c(async function(){const s=Object.create(null);for(let n of Object.keys(t.opIds)){const o=v[n];if(!o)continue;const i=Object.create(null);s[t.opIds[n]]=i,i.key=n,i.f=o}for(;!H;)try{if(Atomics.wait(t.sabOPView,t.opIds.whichOp,0,t.asyncIdleWaitTime)!=="not-equal"){await K();continue}const n=Atomics.load(t.sabOPView,t.opIds.whichOp);Atomics.store(t.sabOPView,t.opIds.whichOp,0);const o=s[n]??f("No waitLoop handler for whichOp #",n),i=t.s11n.deserialize(!0)||[];o.f?await o.f(...i):_("Missing callback for opId",n)}catch(n){_("in waitLoop():",n)}},"f");navigator.storage.getDirectory().then(function(e){t.rootDir=e,globalThis.onmessage=function({data:s}){switch(s.type){case"opfs-async-init":{const n=s.args;for(const o in n)t[o]=n[o];t.verbose=n.verbose??1,t.sabOPView=new Int32Array(t.sabOP),t.sabFileBufView=new Uint8Array(t.sabIO,0,t.fileBufferSize),t.sabS11nView=new Uint8Array(t.sabIO,t.sabS11nOffset,t.sabS11nSize),Object.keys(v).forEach(o=>{Number.isFinite(t.opIds[o])||f("Maintenance required: missing state.opIds[",o,"]")}),G(),d.reset(),T("init state",t),C("opfs-async-inited"),M();break}case"opfs-async-restart":H&&(P("Restarting after opfs-async-shutdown. Might or might not work."),H=!1,M());break;case"opfs-async-metrics":d.dump();break}},C("opfs-async-loaded")}).catch(e=>_("error initializing OPFS asyncer:",e))},"installAsyncProxy");globalThis.SharedArrayBuffer?globalThis.Atomics?!globalThis.FileSystemHandle||!globalThis.FileSystemDirectoryHandle||!globalThis.FileSystemFileHandle||!globalThis.FileSystemFileHandle.prototype.createSyncAccessHandle||!navigator?.storage?.getDirectory?C("opfs-unavailable","Missing required OPFS APIs."):J():C("opfs-unavailable","Missing Atomics API.","The server must emit the COOP/COEP response headers to enable that."):C("opfs-unavailable","Missing SharedArrayBuffer API.","The server must emit the COOP/COEP response headers to enable that.");
//# sourceMappingURL=sqlite3-opfs-async-proxy-CLW7preb.js.map
